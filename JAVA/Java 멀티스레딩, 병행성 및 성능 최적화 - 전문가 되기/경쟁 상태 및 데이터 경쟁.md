### 경쟁 상태 및 데이터 경쟁

---

#### 1. 경쟁 상태

- **정의**:
  - 공유 리소스에 접근하는 여러 스레드가 존재하며, 그 중 적어도 하나의 스레드가 공유 리소스를 수정하는 경우, **스레드 스케줄링**의 순서나 시점에 따라 결과가 달라지는 상황입니다.
- **문제의 핵심**:

  - 공유 리소스에 대해 **비원자적 연산**(atomic operation)이 실행될 때 발생합니다.
  - 즉, 해당 연산이 중단되거나 여러 스레드가 동시에 접근할 때 결과가 예기치 않게 변할 수 있습니다.

- **해결 방법**:
  - 경쟁 상태가 발생하는 **임계 영역**을 **동기화**(synchronized)하여 하나의 스레드만 공유 리소스를 접근하도록 제한합니다.

---

#### 2. 데이터 경쟁

- **정의**:

  - **컴파일러**나 **CPU**가 성능 최적화와 하드웨어 활용을 위해 명령을 **비순차적으로** 실행하는 경우입니다.
  - 이때, 실행 순서가 논리적인 흐름을 위반하지 않으면서도, **동시 실행**되는 스레드들 간에 **예상치 못한 결과**를 초래할 수 있습니다.

- **예시 코드**:

  - **비순차적으로 실행되지 않는 경우**:

    ```java
    public void someFunction() {
        x = 1;
        y = x + 2;
        z = y + 10;
    }
    ```

    - 위 코드는 순차적으로 실행됩니다. `y`는 `x`에 의존하고, `z`는 `y`에 의존하기 때문에 각 코드가 순차적으로 실행되어야 합니다.

  - **비순차적으로 실행될 수 있는 경우**:

    ```java
    public void someFunction1() {
        x++;
        y++;
    }

    public void someFunction2() {
        x++;
        y++;
    }
    ```

    - `x++`와 `y++`는 독립적인 연산으로, **서로의 결과에 의존하지 않기 때문에** CPU나 컴파일러가 이들을 **비순차적으로 실행**할 수 있습니다.
    - 이 경우 의도치 않은 데이터 경쟁이 발생할 수 있습니다.

---

#### 3. 데이터 경쟁 문제

- **문제 발생 원인**:

  - 컴파일러나 CPU가 **다른 코어에서 실행되는 스레드들**을 인식하지 못하고, 동일 변수를 **동시에 읽거나 쓰는 경우**에 **처리 순서**에 의존하게 됩니다.

  - 이로 인해 여러 스레드가 동시에 동일한 변수를 읽고 쓸 때, **동기화되지 않은 상태**에서는 예측할 수 없는 결과가 발생할 수 있습니다. 예를 들어, 두 스레드가 동시에 같은 변수 `x`를 수정할 때, **값이 손실되거나 잘못된 결과를 도출**할 수 있습니다.

- **결과**:
  - 이로 인해 **예상치 못한 잘못된 결과**가 발생하게 되며, 이를 해결하기 위해서는 **동기화(synchronization)** 또는 **원자적 연산(atomic operations)** 등을 사용하여 데이터 경쟁을 방지해야 합니다.

---

### 결론

- **경쟁 상태**는 여러 스레드가 **동시에** 공유 리소스에 접근하여 발생하는 문제로, **동기화**를 통해 해결할 수 있습니다.
- **데이터 경쟁**은 CPU나 컴파일러가 **명령어의 실행 순서를 재배치**하여 발생하는 문제로, **데이터 의존성**을 고려해야 하며, 해결을 위해 **동기화**나 **원자적 연산**을 활용해야 합니다.
